# 基于 Tauri v2 与 ElevenLabs Scribe 构建下一代桌面语音交互系统的深度技术架构报告

## 1. 执行摘要与系统愿景

随着大语言模型（LLM）与实时语音识别技术（ASR）的突破性进展，人机交互（HCI）正处于从传统的"键鼠输入"向"自然语言意图导向"转变的关键节点。Wispr Flow 等工具的出现,标志着一种新型"无头（Headless）"生产力工具的崛起：这类应用常驻后台，无感知地集成于操作系统底层，仅在用户通过特定触发机制（如全局热键）唤醒时介入，通过极低延迟的语音转文本（STT）与意图理解，直接操控当前活跃的应用程序。

本报告旨在为构建一个类似 Wispr Flow 的桌面级实时听写工具提供详尽的技术架构蓝图。该系统基于 Tauri v2 框架构建，利用 Rust 语言的高性能与内存安全性处理底层音频流与系统调用，并集成 ElevenLabs Scribe v2 Realtime API 实现毫秒级的语音转写。报告将深入探讨从音频信号的数字信号处理（DSP）、WebSocket 网络协议的异步并发控制，到 macOS 系统底层的可访问性（Accessibility）API 注入等核心技术挑战。

### 1.1 核心技术栈选型分析

在构建此类系统级工具时，技术选型决定了应用的性能上限与资源占用下限。

| 组件     | 选型方案             | 竞品/替代方案              | 选型深度解析                                                                                                                                                                                        |
|--------|----------------------|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 应用框架 | Tauri v2             | Electron                   | Tauri v2 引入了更细粒度的权限控制（Capabilities）与插件系统。相比 Electron 动辄 100MB+ 的内存占用，Tauri 基于系统原生 Webview（macOS 上为 WKWebView），后端采用 Rust，极大地降低了常驻后台时的资源消耗 [1]。 |
| 后端语言 | Rust                 | Node.js / Python           | 音频采集涉及实时线程处理，任何垃圾回收（GC）造成的停顿都会导致音频爆音或丢失。Rust 的零成本抽象与所有权模型是处理 cpal 音频流与 tokio 异步网络的最佳选择 [3]。                                           |
| ASR 引擎 | ElevenLabs Scribe v2 | Whisper (Local) / Deepgram | Scribe v2 专为实时对话设计，延迟低至 ~150ms，并提供部分转写（Partial Transcript）事件，能够实现"说话即上屏"的流畅体验，优于本地 Whisper 的推理延迟 [5]。                                                   |
| 通信协议 | WebSocket (WSS)      | HTTP/2 Streaming           | 全双工通信是必须的。WSS 允许客户端在流式传输音频的同时，实时接收服务端的 VAD（语音活动检测）事件与文本修正 [6]。                                                                                         |

本报告将严格遵循 Tauri v2 的插件化架构理念，详细阐述如何通过 Rust 实现音频采集、网络传输与系统输入的闭环控制。

## 2. ElevenLabs Scribe v2 API 协议深度解构

在编写任何代码之前，必须透彻理解服务端协议。ElevenLabs Scribe v2 Realtime API 是一个基于 WebSocket 的有状态协议，其设计极其强调低延迟与上下文一致性。

### 2.1 连接握手与鉴权机制

API 的接入点为 `wss://api.elevenlabs.io/v1/speech-to-text/realtime` [8]。鉴权是建立连接的第一道关卡。虽然文档中提到了通过 URL 查询参数 `?token={token}` 进行鉴权的方法（通常用于浏览器端以避免暴露 API Key），但对于编译型的桌面客户端，更安全且标准的做法是使用 HTTP Header 进行鉴权。

根据安全最佳实践，Rust 后端应在 WebSocket 握手请求（Upgrade Request）中注入自定义 Header：

- **Key**: `xi-api-key`
- **Value**: 用户提供的 API 密钥

此外，握手阶段还可以通过查询参数传递初始化配置，这决定了会话的转写行为 [6]：

- **model_id**: 必须指定为 `scribe_v2` 或 `scribe_v2_realtime` [5]。
- **language_code**: 虽然支持自动检测，但在特定场景下显式指定（如 `en`, `zh`）可减少首字延迟 [9]。
- **encoding**: 音频编码格式。默认为 `pcm_16000`（16kHz 采样率的 PCM）。这意味着客户端必须在发送前对音频进行重采样处理，否则会导致语速变慢或变快。

### 2.2 双向消息模型

连接建立后，通信进入全双工模式。Rust 客户端需要处理两类截然不同的消息流。

#### 2.2.1 上行数据流（Client -> Server）

客户端的主要职责是源源不断地发送音频数据。Scribe v2 要求音频数据被封装在 JSON 消息中，而非直接发送二进制帧。根据 [10] 的协议定义，每个消息的结构如下：

```json
{
  "audio_base_64": "<BASE64_ENCODED_PCM_DATA>",
  "message_type": "input_audio_chunk"
}
```

这里存在一个巨大的性能隐患点：**Base64 编码**。音频采集线程通常以极高的频率（如每 10ms）产生数据。如果在音频回调线程中直接进行 Base64 编码和 JSON 序列化，极易造成线程阻塞。因此，架构上必须实现音频数据的"原始搬运"，将编码工作转移到异步任务池中进行。

#### 2.2.2 下行事件流（Server -> Client）

服务端会推送多种类型的事件，客户端必须依据 `message_type` 字段进行分发处理 [10]：

| 事件类型 (message_type) | 触发时机            | 包含数据                | 客户端处理逻辑                                                                         |
|-------------------------|-----------------|-------------------------|---------------------------------------------------------------------------------|
| `session_started`       | 握手成功后立即      | `session_id`, `config`  | 标记连接状态为 Active，通知前端显示"正在听"状态。                                        |
| `partial_transcript`    | 说话过程中          | `text`, `created_at_ms` | 核心事件。这是未定稿的文本（如"hel-"、"hello"）。用于在 UI 悬浮窗中实时展示，给用户即时反馈。 |
| `committed_transcript`  | 句子结束或 VAD 触发 | `text`, `confidence`    | 定稿事件。表示该段文本已确认。此时应触发"文本注入"逻辑，将文本发送到目标应用。             |
| `input_error`           | 数据格式错误        | `error_message`         | 需捕获并反馈给用户（如采样率不匹配）。                                                    |

**深度洞察**：`partial_transcript` 与 `committed_transcript` 的区别处理是实现流畅体验的关键。如果用户说了一长段话，系统会收到数十个 `partial` 事件，但可能只有几个 `committed` 事件。Wispr Flow 的体验精髓在于：在悬浮窗展示 `partial` 内容，但在光标处仅输入 `committed` 内容，或者在悬浮窗定稿后一次性输入。考虑到光标输入的侵入性，最佳实践是在悬浮窗完成视觉确认，待 `committed` 事件到达后，再通过键盘模拟输入。

## 3. Tauri v2 系统架构设计

Tauri v2 相比 v1 发生了重大变革，特别是在插件系统和权限管理上。构建此应用需要重新审视 `src-tauri` 目录下的工程结构。

### 3.1 工程目录与依赖管理

Rust 后端的 `Cargo.toml` 需要引入一系列底层库来支撑音频与系统交互能力。

```toml
[package]
name = "scribeflow-core"
version = "0.1.0"
edition = "2021"

[dependencies]

# Tauri 核心

tauri = { version = "2.0", features = ["tray-icon", "protocol-asset"] }
tauri-plugin-global-shortcut = "2.0" # 全局热键 [11]
tauri-plugin-clipboard-manager = "2.0" # 剪贴板操作 [12]
tauri-plugin-dialog = "2.0" # 系统弹窗 [13]
tauri-plugin-fs = "2.0" # 文件系统（用于缓存配置）

# 异步运行时与网络

tokio = { version = "1", features = ["full"] }
tokio-tungstenite = { version = "0.20", features = ["rustls-tls-native-roots"] } # WebSocket 客户端 [14]
futures-util = "0.3" # 流处理组合子
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 音频处理

cpal = "0.15" # 底层音频 I/O [15]
rubato = "0.14" # 高质量重采样库（用于 48k -> 16k）

# 系统底层交互

enigo = "0.1" # 键盘/鼠标模拟 [16]
active-win-pos-rs = "0.9" # 获取当前活跃窗口信息
accessibility-sys = "0.2" # macOS Accessibility API 绑定 [18]
objc = "0.2" # Objective-C 运行时交互（用于 macOS 权限检查）
```

### 3.2 权限系统（Capabilities）配置

Tauri v2 引入了 ACL（访问控制列表）概念。默认情况下，前端无法调用任何后端指令，除非在 `src-tauri/capabilities/default.json` 中显式授权 [19]。

对于本项目，必须配置以下权限集：

- **Global Shortcut**: 允许前端注册或后端监听 `Cmd+Shift+\`。
- **Clipboard**: 允许写入剪贴板（用于文本注入的回退策略）。
- **Shell/System**: 如果需要执行系统脚本。

```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "global-shortcut:allow-register",
    "global-shortcut:allow-is-registered",
    "clipboard-manager:allow-write-text",
    "clipboard-manager:allow-read-text"
  ]
}
```

**安全隐患提示**：赋予 `clipboard-manager:allow-read-text` 权限需要谨慎，因为这允许应用读取用户的剪贴板历史。作为一款键盘输入工具，我们主要需要 `write` 权限，但在"回退策略"中（即先复制选中内容，再粘贴新内容），可能需要读取权限来保存和恢复剪贴板状态。

### 3.3 系统托盘与后台常驻

应用启动后应默认隐藏主窗口，仅在托盘区显示图标。这需要在 Tauri 的 Builder 中进行配置。根据 [1] 和 [20]，Tauri v2 处理窗口关闭事件的逻辑发生了变化。为了防止用户点击窗口关闭按钮时应用退出，必须拦截 `ExitRequested` 事件：

```rust
// src-tauri/src/lib.rs
pub fn run() {
    tauri::Builder::default()
       .plugin(tauri_plugin_global_shortcut::Builder::new().build())
       .setup(|app| {
            // 初始化托盘图标
            let quit_i = MenuItem::with_id(app, "quit", "Quit", true, None::<&str>)?;
            let settings_i = MenuItem::with_id(app, "settings", "Settings", true, None::<&str>)?;
            let menu = Menu::with_items(app, &[&settings_i, &quit_i])?;

            let _tray = TrayIconBuilder::new()
               .menu(&menu)
               .on_menu_event(|app, event| {
                    match event.id().as_ref() {
                        "quit" => app.exit(0),
                        "settings" => {
                            if let Some(window) = app.get_webview_window("main") {
                                window.show().unwrap();
                                window.set_focus().unwrap();
                            }
                        },
                        _ => {}
                    }
                })
               .build(app)?;
            Ok(())
        })
       .build(tauri::generate_context!())
       .expect("error while building tauri application")
       .run(|app_handle, event| {
            match event {
                tauri::RunEvent::ExitRequested { api,.. } => {
                    // 核心逻辑：拦截退出，改为隐藏
                    api.prevent_exit();
                },
                tauri::RunEvent::WindowEvent { label, event: tauri::WindowEvent::CloseRequested { api,.. },.. } => {
                     if label == "main" {
                        api.prevent_close();
                        if let Some(window) = app_handle.get_webview_window("main") {
                            window.hide().unwrap();
                        }
                     }
                }
                _ => {}
            }
        });
}
```

**macOS 特有的 App Nap 问题**：macOS 会挂起后台不可见应用的 Webview 进程以节省电量 [21]。这会导致 WebSocket 心跳丢失或 UI 更新延迟。虽然我们的核心逻辑在 Rust 后端（不受 Webview 挂起影响），但如果依赖前端更新悬浮窗 UI，则必须处理此问题。解决方案是在 `tauri.conf.json` 中设置 `macOSPrivateApi: true` 并配置后台模式，或者依靠 Rust 端全权处理网络，仅在有数据时唤醒 UI。

## 4. 音频采集与处理流水线 (DSP Pipeline)

这是系统的"心脏"。我们必须使用 `cpal` 库直接与操作系统的音频守护进程（CoreAudio, WASAPI, ALSA）交互 [15]。

### 4.1 音频设备枚举与配置

`cpal` 的工作流程是：Host -> Device -> Config -> Stream。

```rust
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};

fn setup_audio_stream() -> Result<cpal::Stream, anyhow::Error> {
    let host = cpal::default_host();
    // 获取默认输入设备（麦克风）
    let device = host.default_input_device().ok_or(anyhow!("No input device available"))?;

    // 获取设备支持的配置
    let supported_config = device.default_input_config()?;
    let config: cpal::StreamConfig = supported_config.clone().into();

    // 关键决策点：采样率
    // 大多数麦克风原生支持 44100Hz 或 48000Hz。
    // Scribe v2 期望 16000Hz。
    // 我们必须在 Rust 中进行重采样，或者发送原始数据让服务端处理（耗费带宽）。
    // 推荐方案：本地重采样。
}
```

### 4.2 线程模型：从回调到异步通道

`cpal` 使用回调函数 `data_callback` 来传递音频数据。这个回调是在一个高优先级的音频线程中执行的。严禁在此线程中执行以下操作：

- 网络 I/O（WebSocket 发送）。
- 内存分配（尽量避免大规模 Vec 分配）。
- 互斥锁竞争（可能导致优先级反转）。

**架构设计**：使用无锁队列（Ring Buffer）或 `tokio::sync::mpsc` 通道将数据"搬运"到 Tokio 运行时。

```rust
use std::sync::mpsc;

// 定义通道传输的数据类型
type AudioPacket = Vec<f32>;

let (producer, consumer) = mpsc::channel::<AudioPacket>();

let stream = device.build_input_stream(
    &config,
    move |data: &[f32], _: &cpal::InputCallbackInfo| {
        // 在这里进行最小限度的处理，例如将 slice 转为 Vec
        // 注意：频繁分配 Vec 仍有开销，生产环境应使用预分配的 RingBuffer
        if let Err(e) = producer.send(data.to_vec()) {
            eprintln!("Failed to send audio chunk: {}", e);
        }
    },
    move |err| eprintln!("Stream error: {}", err),
    None
)?;
```

**进阶优化**：为了匹配 Scribe v2 的块大小要求并减少网络包数量，可以在 `producer` 发送前引入一个中间缓冲层，每积攒 100ms 的数据（例如 16kHz 下的 1600 个采样点）才通过通道发送一次。

### 4.3 重采样（Resampling）

如果麦克风是 48kHz，直接丢弃采样点（Decimation）会引入混叠噪声。必须使用 `rubato` 等库进行高质量重采样。

**算法选择**：Sinc 插值或多相滤波。

**Rust 实现逻辑**：

1. 在 `cpal` 回调中收集 48kHz 数据。
2. 当缓冲区达到一定大小时（如 480 帧），调用重采样器。
3. 输出 160 帧（16kHz）数据，推入发送队列。

## 5. 实时网络传输层实现

网络层负责将采集到的 PCM 数据流式传输给 ElevenLabs，并处理返回的文本。这里使用 `tokio-tungstenite` 实现异步 WebSocket 客户端 [23]。

### 5.1 状态机设计

由于应用是基于热键触发的，网络连接管理至关重要。

- **Cold Start（冷启动）**：每次按下热键才建立连接。优点是省流省资源；缺点是首字延迟（DNS + TCP握手 + SSL握手 + WS升级 ≈ 300-500ms）。
- **Warm Connection（热连接）**：保持长连接，静音时发送 Ping。优点是响应极快；缺点是长期占用资源且 ElevenLabs 可能会断开空闲连接（Inactivity Timeout [6]）。

**推荐策略**：采用"预热"策略。

1. 应用启动时建立连接。
2. 如果 30 秒无操作，断开连接。
3. 当用户按下 `Cmd+Shift`（还未按 `\`）时，提前发起连接（Speculative Connection）。

### 5.2 发送循环（Tx Task）

```rust
// 伪代码：音频发送任务
async fn audio_sender_task(mut ws_write: SplitSink<...>, mut audio_rx: Receiver<Vec<f32>>) {
    while let Some(chunk) = audio_rx.recv().await {
        // 1. PCM f32 -> PCM i16 (Scribe v2 可能偏好 i16 以减小体积)
        let pcm_i16: Vec<i16> = chunk.iter().map(|&x| (x * 32767.0) as i16).collect();

        // 2. Base64 编码
        let b64 = base64::engine::general_purpose::STANDARD.encode(as_u8_slice(&pcm_i16));

        // 3. 构造 JSON
        let payload = json!({
            "audio_base_64": b64,
            "message_type": "input_audio_chunk"
        });

        // 4. 发送
        ws_write.send(Message::Text(payload.to_string())).await?;
    }
}
```

**重要细节**：Scribe v2 的 `input_audio_chunk` 不需要包含时间戳，服务端会根据接收顺序处理。

### 5.3 接收循环（Rx Task）与事件分发

接收任务需要持续监听 WebSocket 的 `read` 端。

```rust
async fn response_listener_task(mut ws_read: SplitStream<...>, app_handle: AppHandle) {
    while let Some(msg) = ws_read.next().await {
        let text = msg.unwrap().into_text().unwrap();
        let event: ScribeEvent = serde_json::from_str(&text).unwrap();

        match event.message_type.as_str() {
            "partial_transcript" => {
                // 触发前端更新悬浮窗
                app_handle.emit("transcript_update", Payload {
                    text: event.text,
                    is_final: false
                }).unwrap();
            },
            "committed_transcript" => {
                // 1. 更新前端
                app_handle.emit("transcript_update", Payload {
                    text: event.text.clone(),
                    is_final: true
                }).unwrap();

                // 2. 执行系统输入（由另一个专门的 Input Task 处理，避免阻塞网络）
                input_tx.send(event.text).await.unwrap();
            }
            _ => {}
        }
    }
}
```

## 6. 操作系统级输入注入与上下文感知

这是应用最"黑科技"的部分，也是实现 Wispr Flow 体验的关键。

### 6.1 活跃窗口检测与上下文获取

为了知道"往哪里输入"，我们需要获取当前活跃窗口的信息。使用 `active-win-pos-rs` 库 [17]。

```rust
use active_win_pos_rs::get_active_window;

fn get_target_app() {
    match get_active_window() {
        Ok(active_window) => {
            println!("App: {}, Title: {}", active_window.app_name, active_window.title);
            // 可以在此实现黑名单逻辑（例如：不在密码框或特定游戏中触发）
        },
        Err(()) => println!("无法获取活跃窗口"),
    }
}
```

**macOS 权限陷阱**：在 macOS 上获取窗口标题需要"屏幕录制（Screen Recording）"权限 [17]。如果未授权，只能获取到应用名称，标题为空。对于输入功能，应用名称通常足够，但若要实现"根据上下文优化识别（Prompt Engineering）"，则需要标题信息。

### 6.2 文本注入策略对比与实现

| 策略               | 实现原理                               | 优点                                        | 缺点                                               | 适用场景        |
|------------------|------------------------------------|-------------------------------------------|--------------------------------------------------|-------------|
| 键盘模拟 (Enigo)   | 模拟按键序列 (Key Sequence)            | 兼容性最高，无需特殊权限（除了 Accessibility） | 速度慢，长文本输入像"幽灵打字"；期间用户动鼠标会打断 | 短语、修正输入   |
| 剪贴板注入 (Paste) | 设置剪贴板 -> 发送 Cmd+V -> 恢复剪贴板 | 速度极快，瞬间上屏                           | 会污染剪贴板历史；部分应用禁止快速粘贴；需读写权限   | 长段落、整句输入 |

**混合策略（Hybrid Injection）**：为了达到最佳体验，建议采用混合策略：

对于短句（< 10 字符），使用 `enigo` 模拟按键。

对于长句，使用剪贴板注入。

- **步骤 1**: 读取并缓存当前剪贴板内容（`clipboard.read_text()`）。
- **步骤 2**: 写入转写文本。
- **步骤 3**: 触发 `Cmd+V` (macOS) 或 `Ctrl+V` (Windows)。
- **步骤 4**: 延时 100ms（等待系统处理粘贴事件）。
- **步骤 5**: 恢复旧的剪贴板内容。

**Focus Management（焦点管理）的挑战**：当用户按下快捷键唤醒 Tauri 的悬浮窗时，焦点可能会转移到 Tauri 窗口。此时如果直接模拟键盘输入，字会打在悬浮窗里，而不是原来的 Word 文档里。

**解决方案**：

- 配置 Tauri 窗口为 `acceptFirstMouse: false` 和 `focusable: false`（在 `tauri.conf.json` 中需开启 `macOSPrivateApi` 并设置面板属性 [26]）。
- 或者，在输入前显式隐藏 Tauri 窗口 (`window.hide()`)。隐藏操作通常会将焦点交还给上一个活跃窗口（即用户的文档）。
- 使用 `enigo` 发送输入前，确保焦点已归还。

### 6.3 Accessibility API (macOS 深度集成)

在 macOS 上，模拟按键依赖于 Accessibility API。应用必须被列入"辅助功能"信任列表。

**Rust 检测代码**：可以使用 `macos-accessibility-client` crate 来检查权限 [27]。

```rust
use macos_accessibility_client::accessibility::application_is_trusted;

fn check_permissions() {
    if !application_is_trusted() {
        // 弹窗提示用户去设置开启权限
        // 并尝试触发系统请求提示
        let _ = macos_accessibility_client::accessibility::application_is_trusted_with_prompt();
    }
}
```

此外，利用 AXUIElement API [28]，我们可以进一步检测当前焦点元素是否为"可编辑文本区域"（`AXTextArea` 或 `AXTextField`）。如果检测到非编辑区域（如网页的正文阅读区），应用可以智能地改为"仅复制到剪贴板"模式，并在 UI 上提示用户。

## 7. 前端交互与 UX 设计

虽然核心逻辑在后端，但前端决定了用户的感知体验。

### 7.1 悬浮窗实现 (Wispr Flow Style)

悬浮窗需要具备以下特性：

- **透明背景**：仅显示文字和简单的背景条。
- **位置跟随**：理想情况下跟随光标位置。
- **极简动画**：波形动画展示麦克风音量。

**Tauri 窗口配置**：

```json
"windows": [
  {
    "label": "overlay",
    "title": "Voice Overlay",
    "width": 400,
    "height": 100,
    "decorations": false,
    "transparent": true,
    "alwaysOnTop": true,
    "skipTaskbar": true,
    "visible": false,
    "center": true
  }
]
```

### 7.2 前后端通信

使用 Tauri 的 Event 系统实现高频数据同步。

- **Audio Level**: Rust 端计算 RMS（均方根）音量，每 50ms 发送一次 `audio-level` 事件，前端 CSS 根据数值渲染波形。
- **Transcript**: Rust 端收到 WebSocket 消息后，立即 `emit` `partial-transcript`，前端 React 组件更新 State 渲染文字。

## 8. 结论与未来展望

构建一个基于 Tauri v2 和 ElevenLabs Scribe 的实时听写工具，是一项融合了系统编程、网络工程与音频处理的综合性挑战。本报告详细阐述了如何通过 Rust 强大的生态系统（cpal, tokio, tungstenite）构建高可靠的后端服务，解决了音频流的实时编码与 WebSocket 并发传输问题。同时，通过深入 macOS 的 Accessibility 与 Window Management 机制，实现了"无缝注入"这一核心产品体验。

**未来的优化方向**：

1. **本地 VAD 集成**：在 Rust 端集成 `silero-vad`，在发送音频给 ElevenLabs 之前就过滤掉静音片段，大幅节省 API 调用成本并降低误识别率。

2. **上下文感知 Prompt**：读取当前窗口的标题甚至内容（需要 OCR 或 Accessibility 读取权限），将其作为 Prompt 发送给 ElevenLabs，从而提高专业术语的识别准确率。

3. **离线模式**：集成 `whisper.cpp` 作为离线备选方案，当网络不稳定时自动降级到本地模型。

该架构不仅适用于简单的听写工具，更为构建下一代 AI 辅助输入系统奠定了坚实的基础。

---

## 关键引用索引

- [1] Tauri v2 系统托盘与事件循环
- [3] Rust 内存安全与性能
- [4] Rust cpal 音频流处理
- [5] ElevenLabs Scribe v2 特性
- [6] WebSocket 全双工通信
- [8] ElevenLabs API 端点
- [9] 语言代码配置
- [10] ElevenLabs WebSocket 协议细节
- [11] 全局热键注册机制
- [12] 剪贴板操作
- [13] 系统弹窗
- [14] WebSocket 客户端
- [15] 音频 I/O
- [16] 键盘鼠标模拟
- [17] 活跃窗口检测
- [18] macOS Accessibility 集成
- [19] Tauri v2 权限系统
- [20] 窗口事件处理
- [21] macOS App Nap
- [23] 异步 WebSocket
- [26] Tauri 窗口配置
- [27] macOS 权限检查
- [28] AXUIElement API
